//! Melee combat system: attack phases, hitbox collision, defensive mechanics.
//!
//! # Architecture
//!
//! **ECS (Strategic Layer):**
//! - `MeleeAttackState`: track attack phases (windup ‚Üí active ‚Üí recovery)
//! - `MeleeAttackIntent`: AI wants to attack (strategic decision)
//! - `MeleeAttackStarted`: attack approved by Godot (tactical validation)
//!
//! **Godot (Tactical Layer):**
//! - `MeleeHit`: hitbox collision detected (Godot ‚Üí ECS)
//! - Area3D hitbox: collision detection, animation-driven
//!
//! # Attack Flow
//!
//! ```text
//! AI decision ‚Üí MeleeAttackIntent (ECS)
//!   ‚Üì
//! Godot validates distance/LOS ‚Üí MeleeAttackStarted (ECS)
//!   ‚Üì
//! ECS adds MeleeAttackState (phase = Windup)
//!   ‚Üì
//! Godot triggers animation + enables hitbox
//!   ‚Üì
//! Hitbox collision ‚Üí MeleeHit (Godot ‚Üí ECS)
//!   ‚Üì
//! ECS processes damage ‚Üí DamageDealt event
//! ```

use bevy::prelude::*;

// ============================================================================
// Components
// ============================================================================

/// Tracks melee attack phases (windup ‚Üí active ‚Üí recovery).
///
/// Added to actor when they start a melee attack.
/// Removed when attack completes (returns to Idle phase).
#[derive(Component, Clone, Debug, Reflect)]
#[reflect(Component)]
pub struct MeleeAttackState {
    /// Current attack phase
    pub phase: AttackPhase,
    /// Time remaining in current phase (seconds)
    pub phase_timer: f32,
    /// Entity being attacked
    pub target: Entity,
    /// Has already hit target this attack? (prevents multiple hits)
    pub has_hit_target: bool,
}

impl MeleeAttackState {
    /// Create new attack state in Windup phase.
    pub fn new_windup(target: Entity, windup_duration: f32) -> Self {
        Self {
            phase: AttackPhase::Windup {
                duration: windup_duration,
            },
            phase_timer: windup_duration,
            target,
            has_hit_target: false,
        }
    }

    /// Check if attack is in Active phase (hitbox enabled).
    pub fn is_active(&self) -> bool {
        matches!(self.phase, AttackPhase::Active { .. })
    }

    /// Check if attack is in Windup phase (telegraphed to enemy).
    pub fn is_windup(&self) -> bool {
        matches!(self.phase, AttackPhase::Windup { .. })
    }

    /// Check if attack is in Recovery phase (vulnerable).
    pub fn is_recovery(&self) -> bool {
        matches!(self.phase, AttackPhase::Recovery { .. })
    }

    /// Advance to next attack phase.
    ///
    /// # Phase transitions
    ///
    /// - Windup ‚Üí Active
    /// - Active ‚Üí Recovery
    /// - Recovery ‚Üí Idle (returns None, state should be removed)
    pub fn advance_phase(&mut self) -> Option<AttackPhase> {
        match self.phase {
            AttackPhase::Windup { .. } => {
                // Transition: Windup ‚Üí Active
                // Duration will be set by caller (from WeaponStats)
                self.phase = AttackPhase::Active { duration: 0.0 };
                Some(self.phase.clone())
            }
            AttackPhase::Active { .. } => {
                // Transition: Active ‚Üí Recovery
                self.phase = AttackPhase::Recovery { duration: 0.0 };
                Some(self.phase.clone())
            }
            AttackPhase::Recovery { .. } => {
                // Transition: Recovery ‚Üí Idle (attack complete)
                self.phase = AttackPhase::Idle;
                None
            }
            AttackPhase::Idle => None,
        }
    }
}

/// Attack phases for melee combat.
///
/// # Phases
///
/// 1. **Windup**: Telegraphs attack to enemy (visible to AI)
/// 2. **Active**: Hitbox enabled, can hit targets
/// 3. **Recovery**: Vulnerable state, cannot attack/block
/// 4. **Idle**: Not attacking (state removed from entity)
#[derive(Clone, Debug, Reflect, PartialEq)]
pub enum AttackPhase {
    /// Not attacking (default state, component removed)
    Idle,
    /// Windup/telegraph phase (enemy can react)
    Windup { duration: f32 },
    /// Active attack phase (hitbox enabled)
    Active { duration: f32 },
    /// Recovery phase (vulnerable)
    Recovery { duration: f32 },
}

// ============================================================================
// Events
// ============================================================================

/// AI wants to perform a melee attack (ECS strategic decision).
///
/// Generated by `ai_melee_attack_intent` system when:
/// - AI is in Combat state
/// - Weapon is melee type
/// - Target is within attack radius (strategic estimate)
/// - Cooldown is ready
///
/// Processed by `process_melee_attack_intents_main_thread` (Godot tactical validation).
#[derive(Event, Clone, Debug)]
pub struct MeleeAttackIntent {
    /// Entity initiating attack
    pub attacker: Entity,
    /// Target entity
    pub target: Entity,
    /// Attack type (Normal/Heavy/Quick)
    pub attack_type: MeleeAttackType,
}

/// Type of melee attack.
#[derive(Clone, Debug, PartialEq, Reflect)]
pub enum MeleeAttackType {
    /// Normal attack (default)
    Normal,
    /// Heavy attack (slow, high damage) - TODO: future
    Heavy,
    /// Quick attack (fast, low damage) - TODO: future
    Quick,
}

/// Melee attack has been approved and started (Godot tactical validation passed).
///
/// Generated by `process_melee_attack_intents_main_thread` after:
/// - Distance check (Godot Transform)
/// - Line of sight check (optional)
///
/// Processed by `start_melee_attacks` system (ECS):
/// - Adds `MeleeAttackState` component (phase = Windup)
/// - Starts weapon cooldown
#[derive(Event, Clone, Debug)]
pub struct MeleeAttackStarted {
    /// Entity performing attack
    pub attacker: Entity,
    /// Target entity
    pub target: Entity,
    /// Attack type
    pub attack_type: MeleeAttackType,
    /// Windup phase duration (seconds)
    pub windup_duration: f32,
    /// Active phase duration (seconds)
    pub attack_duration: f32,
    /// Recovery phase duration (seconds)
    pub recovery_duration: f32,
}

/// Melee hitbox collision detected (Godot ‚Üí ECS).
///
/// Generated by Godot when weapon hitbox (Area3D) collides with target.
/// Queued in `MELEE_HIT_QUEUE`, processed by `process_melee_hits` system.
///
/// Results in `DamageDealt` event if not blocked/parried.
#[derive(Event, Clone, Debug)]
pub struct MeleeHit {
    /// Entity that hit
    pub attacker: Entity,
    /// Entity that was hit
    pub target: Entity,
    /// Base damage (before modifiers)
    pub damage: u32,
    /// Was attack blocked? (damage reduction 70%)
    pub was_blocked: bool,
    /// Was attack parried? (damage negated 100%, attacker staggered)
    pub was_parried: bool,
}

// ============================================================================
// Static queue for MeleeHit (Godot ‚Üí ECS communication)
// ============================================================================

use std::sync::Mutex;

/// Global queue for melee hit events (Godot ‚Üí ECS).
///
/// Godot thread pushes `MeleeHit` events when hitbox collides.
/// ECS `process_melee_hits` system drains queue and processes damage.
static MELEE_HIT_QUEUE: Mutex<Vec<MeleeHit>> = Mutex::new(Vec::new());

/// Push melee hit event from Godot thread.
///
/// Called when weapon hitbox (Area3D) detects collision.
pub fn push_melee_hit(hit: MeleeHit) {
    if let Ok(mut queue) = MELEE_HIT_QUEUE.lock() {
        queue.push(hit);
    }
}

/// Drain melee hit queue (ECS systems).
///
/// Returns all pending hits, clears queue.
pub fn drain_melee_hit_queue() -> Vec<MeleeHit> {
    MELEE_HIT_QUEUE
        .lock()
        .map(|mut queue| queue.drain(..).collect())
        .unwrap_or_default()
}

// ============================================================================
// ECS Systems (Strategic Layer)
// ============================================================================

use crate::ai::AIState;
use crate::components::{Health, Stamina, StrategicPosition};
use crate::combat::{DamageDealt, WeaponStats};

/// System: AI generates melee attack intents (ECS strategic decision).
///
/// Runs when:
/// - AI is in Combat state
/// - Weapon is melee type
/// - Target within attack radius (strategic estimate)
/// - Weapon cooldown ready
/// - Has stamina for attack
///
/// Generates `MeleeAttackIntent` event for Godot tactical validation.
pub fn ai_melee_attack_intent(
    ai_query: Query<(Entity, &AIState, &WeaponStats, &Stamina)>,
    mut intent_events: EventWriter<MeleeAttackIntent>,
) {
    for (attacker, ai_state, weapon, stamina) in ai_query.iter() {
        // Only in Combat state
        let AIState::Combat { target } = ai_state else {
            continue;
        };

        // Only melee weapons
        if !weapon.is_melee() {
            continue;
        }

        // Check weapon cooldown
        if !weapon.can_attack() {
            crate::log(&format!("‚è≥ {:?} melee intent: weapon on cooldown ({:.2}s)", attacker, weapon.cooldown_timer));
            continue;
        }

        // Check stamina (attack cost 30)
        const ATTACK_COST: f32 = 30.0;
        if stamina.current < ATTACK_COST {
            crate::log(&format!("üí® {:?} melee intent: not enough stamina ({:.0}/{:.0})", attacker, stamina.current, ATTACK_COST));
            continue;
        }

        // ‚úÖ Generate intent (distance check –≤ Godot tactical validation!)
        // ECS —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–æ–µ —Ä–µ—à–µ–Ω–∏–µ: AI —Ö–æ—á–µ—Ç –∞—Ç–∞–∫–æ–≤–∞—Ç—å
        // Godot —Ç–∞–∫—Ç–∏—á–µ—Å–∫–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è: –ø—Ä–æ–≤–µ—Ä–∏—Ç distance/LOS –ø–æ –∞–∫—Ç—É–∞–ª—å–Ω—ã–º Transform
        intent_events.write(MeleeAttackIntent {
            attacker,
            target: *target,
            attack_type: MeleeAttackType::Normal,
        });

        crate::log(&format!(
            "üó°Ô∏è ECS: Melee attack intent generated (attacker: {:?}, target: {:?})",
            attacker, target
        ));
    }
}

/// System: Start melee attacks (process MeleeAttackStarted events).
///
/// When Godot approves attack (tactical validation passed):
/// - Adds `MeleeAttackState` component (phase = Windup)
/// - Starts weapon cooldown
/// - Consumes stamina
pub fn start_melee_attacks(
    mut started_events: EventReader<MeleeAttackStarted>,
    mut commands: Commands,
    mut weapons: Query<&mut WeaponStats>,
    mut staminas: Query<&mut Stamina>,
) {
    for event in started_events.read() {
        // Add MeleeAttackState (phase = Windup)
        commands.entity(event.attacker).insert(
            MeleeAttackState::new_windup(event.target, event.windup_duration)
        );

        // Start weapon cooldown
        if let Ok(mut weapon) = weapons.get_mut(event.attacker) {
            weapon.start_cooldown();
        }

        // Consume stamina (attack cost)
        const ATTACK_COST: f32 = 30.0;
        if let Ok(mut stamina) = staminas.get_mut(event.attacker) {
            stamina.consume(ATTACK_COST);
        }

        crate::log(&format!(
            "‚öîÔ∏è ECS: Melee attack started (attacker: {:?}, target: {:?}, windup: {:.2}s)",
            event.attacker, event.target, event.windup_duration
        ));
    }
}

/// System: Update melee attack phases (windup ‚Üí active ‚Üí recovery ‚Üí idle).
///
/// Advances attack phases based on timers.
/// When phase = Idle ‚Üí removes MeleeAttackState component.
pub fn update_melee_attack_phases(
    mut query: Query<(Entity, &mut MeleeAttackState)>,
    weapons: Query<&WeaponStats>,
    time: Res<Time<Fixed>>,
    mut commands: Commands,
) {
    let delta = time.delta_secs();

    for (entity, mut attack_state) in query.iter_mut() {
        // Decrease phase timer
        attack_state.phase_timer -= delta;

        // Phase transition when timer expires
        if attack_state.phase_timer <= 0.0 {
            let Some(new_phase) = attack_state.advance_phase() else {
                // Attack complete (Idle) ‚Üí remove component
                commands.entity(entity).remove::<MeleeAttackState>();
                crate::log(&format!("‚úÖ ECS: Melee attack completed (entity: {:?})", entity));
                continue;
            };

            // Get weapon stats for phase durations
            let Ok(weapon) = weapons.get(entity) else {
                continue;
            };

            // Set new phase timer based on phase type
            match new_phase {
                AttackPhase::Active { .. } => {
                    attack_state.phase = AttackPhase::Active {
                        duration: weapon.attack_duration,
                    };
                    attack_state.phase_timer = weapon.attack_duration;
                    crate::log(&format!("‚öîÔ∏è ECS: Windup ‚Üí Active (entity: {:?})", entity));
                }
                AttackPhase::Recovery { .. } => {
                    attack_state.phase = AttackPhase::Recovery {
                        duration: weapon.recovery_duration,
                    };
                    attack_state.phase_timer = weapon.recovery_duration;
                    crate::log(&format!("üõ°Ô∏è ECS: Active ‚Üí Recovery (entity: {:?})", entity));
                }
                _ => {}
            }
        }
    }
}

/// System: Process melee hits (Godot ‚Üí ECS damage application).
///
/// Reads `MeleeHit` events, applies damage with modifiers:
/// - Blocked: 70% damage reduction
/// - Parried: 100% damage negation + stagger attacker
/// - Normal: full damage
///
/// Generates `DamageDealt` events.
pub fn process_melee_hits(
    mut melee_hit_events: EventReader<MeleeHit>,
    mut damage_dealt_events: EventWriter<DamageDealt>,
    mut healths: Query<&mut Health>,
    _weapons: Query<&WeaponStats>,
) {
    for hit in melee_hit_events.read() {
        // Skip self-hits
        if hit.attacker == hit.target {
            continue;
        }

        // Calculate damage with modifiers
        let mut final_damage = hit.damage;

        if hit.was_parried {
            // Parried: 100% negation
            final_damage = 0;
            crate::log(&format!(
                "üõ°Ô∏è Melee hit PARRIED (attacker: {:?}, target: {:?})",
                hit.attacker, hit.target
            ));

            // Stagger attacker (increase cooldown by 0.5s)
            // TODO: Implement when parry system is ready

        } else if hit.was_blocked {
            // Blocked: 70% reduction
            final_damage = (final_damage as f32 * 0.3) as u32;
            crate::log(&format!(
                "üõ°Ô∏è Melee hit BLOCKED (attacker: {:?}, target: {:?}, reduced damage: {})",
                hit.attacker, hit.target, final_damage
            ));
        }

        // Apply damage
        if final_damage > 0 {
            if let Ok(mut health) = healths.get_mut(hit.target) {
                health.take_damage(final_damage);

                // Generate DamageDealt event
                damage_dealt_events.write(DamageDealt {
                    attacker: hit.attacker,
                    target: hit.target,
                    damage: final_damage,
                    source: crate::combat::DamageSource::Melee,
                });

                crate::log(&format!(
                    "üí• Melee damage dealt (attacker: {:?}, target: {:?}, damage: {}, health: {} ‚Üí {})",
                    hit.attacker, hit.target, final_damage,
                    health.current + final_damage, health.current
                ));
            }
        }
    }
}
