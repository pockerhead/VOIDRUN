//! Weapon system - events –¥–ª—è ranged combat
//!
//! Architecture:
//! - ECS: WeaponStats (cooldown, decisions) –≤ weapon_stats.rs
//! - Godot: Aim execution (bone rotation), Fire visual (spawn projectile)
//! - Events: WeaponFired (ECS‚ÜíGodot), ProjectileHit (Godot‚ÜíECS)

use bevy::prelude::*;

// ‚ùå Projectile –ù–ï —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ ECS ‚Äî —Ç–æ–ª—å–∫–æ –≤ Godot (tactical layer)
// Godot –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–ª–∞–¥–µ–µ—Ç lifecycle: spawn, physics, collision, cleanup
// ECS –æ—Ç–≤–µ—á–∞–µ—Ç —Ç–æ–ª—å–∫–æ –∑–∞ Weapon state –∏ damage calculation

/// Event: –ê–∫—Ç—ë—Ä –•–û–ß–ï–¢ –≤—ã—Å—Ç—Ä–µ–ª–∏—Ç—å (ECS strategic intent)
/// ECS –ø—Ä–∏–Ω–∏–º–∞–µ—Ç strategic decision: "cooldown –≥–æ—Ç–æ–≤, target –≤ Combat state"
/// Godot validation –ø—Ä–æ–≤–µ—Ä—è–µ—Ç tactical constraints: distance, LOS
///
/// **Note:** `target` –æ–ø—Ü–∏–æ–Ω–∞–ª–µ–Ω –¥–ª—è player FPS shooting (direction = camera forward)
#[derive(Event, Debug, Clone)]
pub struct WeaponFireIntent {
    /// –ö—Ç–æ —Ö–æ—á–µ—Ç —Å—Ç—Ä–µ–ª—è—Ç—å
    pub shooter: Entity,

    /// –í –∫–æ–≥–æ —Ö–æ—á–µ—Ç —Å—Ç—Ä–µ–ª—è—Ç—å (None = player FPS shooting –±–µ–∑ target)
    pub target: Option<Entity>,

    /// –£—Ä–æ–Ω (–∏–∑ Weapon component)
    pub damage: u32,

    /// –°–∫–æ—Ä–æ—Å—Ç—å –ø—É–ª–∏ (–∏–∑ Weapon component)
    pub speed: f32,

    /// Max range (–∏–∑ Weapon component)
    pub max_range: f32,

    /// –†–∞–¥–∏—É—Å —Å–ª—ã—à–∏–º–æ—Å—Ç–∏ –≤—ã—Å—Ç—Ä–µ–ª–∞ (–¥–ª—è AI reaction)
    pub hearing_range: f32,
}

/// Event: –ê–∫—Ç—ë—Ä —Å—Ç—Ä–µ–ª—è–µ—Ç (ECS ‚Üí Godot, –ø–æ—Å–ª–µ validation)
/// Godot tactical layer –ø—Ä–æ–≤–µ—Ä–∏–ª distance/LOS –∏ —Ä–∞–∑—Ä–µ—à–∏–ª –≤—ã—Å—Ç—Ä–µ–ª
/// Godot —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç —Ç–æ—á–Ω–æ–µ direction –∏–∑ weapon bone (+Z axis)
///
/// **Note:** `target` –æ–ø—Ü–∏–æ–Ω–∞–ª–µ–Ω (None = player FPS shooting, direction = weapon forward)
#[derive(Event, Debug, Clone)]
pub struct WeaponFired {
    /// –ö—Ç–æ —Å—Ç—Ä–µ–ª—è–µ—Ç
    pub shooter: Entity,

    /// –í –∫–æ–≥–æ —Å—Ç—Ä–µ–ª—è–µ—Ç (None = –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–∑ weapon bone, Some = fallback shooter‚Üítarget)
    pub target: Option<Entity>,

    /// –£—Ä–æ–Ω –ø—É–ª–∏
    pub damage: u32,

    /// –°–∫–æ—Ä–æ—Å—Ç—å –ø—É–ª–∏
    pub speed: f32,

    /// –ü–æ–∑–∏—Ü–∏—è —Å—Ç—Ä–µ–ª—è–≤—à–µ–≥–æ (Godot Transform, –¥–ª—è AI sound reaction)
    pub shooter_position: Vec3,

    /// –†–∞–¥–∏—É—Å —Å–ª—ã—à–∏–º–æ—Å—Ç–∏ –≤—ã—Å—Ç—Ä–µ–ª–∞ (–¥–ª—è AI reaction)
    pub hearing_range: f32,
}

/// Event: Projectile –ø–æ–ø–∞–ª –≤ —Ü–µ–ª—å (Godot ‚Üí ECS)
#[derive(Event, Debug, Clone)]
pub struct ProjectileHit {
    /// –ö—Ç–æ –≤—ã—Å—Ç—Ä–µ–ª–∏–ª (–¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è self-hit)
    pub shooter: Entity,

    /// –í –∫–æ–≥–æ –ø–æ–ø–∞–ª–∏
    pub target: Entity,

    /// –£—Ä–æ–Ω
    pub damage: u32,

    /// –¢–æ—á–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è (–¥–ª—è VFX)
    pub impact_point: Vec3,

    /// –ù–æ—Ä–º–∞–ª—å –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ (–¥–ª—è VFX –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è)
    pub impact_normal: Vec3,
}

/// Event: Projectile –ø–æ–ø–∞–ª –≤ —â–∏—Ç (Godot ‚Üí ECS)
///
/// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –∫–æ–≥–¥–∞ projectile –∫–æ–ª–ª–∏–¥–∏—Ä—É–µ—Ç —Å ShieldSphere (Area3D).
/// Shield –±–ª–æ–∫–∏—Ä—É–µ—Ç projectile –µ—Å–ª–∏:
/// - shooter != target (—Å–≤–æ–π —â–∏—Ç –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç)
/// - shield.is_active() (energy > 0)
#[derive(Event, Debug, Clone)]
pub struct ProjectileShieldHit {
    /// Projectile entity (–¥–ª—è despawn –≤ Godot)
    pub projectile: Entity,

    /// –ö—Ç–æ –≤—ã—Å—Ç—Ä–µ–ª–∏–ª
    pub shooter: Entity,

    /// –í–ª–∞–¥–µ–ª–µ—Ü —â–∏—Ç–∞ (target)
    pub target: Entity,

    /// –£—Ä–æ–Ω
    pub damage: u32,

    /// –¢–æ—á–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –≤ —â–∏—Ç (–¥–ª—è ripple VFX)
    pub impact_point: Vec3,

    /// –ù–æ—Ä–º–∞–ª—å –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ (–¥–ª—è VFX –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è)
    pub impact_normal: Vec3,
}


/// System: AI weapon fire intent (ECS strategic decision)
///
/// –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ (Hybrid Intent-based):
/// 1. ECS (strategic): –ü—Ä–æ–≤–µ—Ä—è–µ—Ç cooldown + AI state ‚Üí –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç WeaponFireIntent
/// 2. Godot (tactical): –ü—Ä–æ–≤–µ—Ä—è–µ—Ç distance/LOS ‚Üí –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç Intent ‚Üí WeaponFired
///
/// –ü–æ—á–µ–º—É —Ç–∞–∫:
/// - ECS –Ω–µ –∑–Ω–∞–µ—Ç —Ç–æ—á–Ω—ã—Ö Godot positions (—Ç–æ–ª—å–∫–æ chunk-based StrategicPosition)
/// - Godot authoritative –¥–ª—è tactical validation (distance, line of sight)
/// - –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏: strategic intent vs tactical execution
pub fn ai_weapon_fire_intent(
    mut actors: Query<(Entity, &crate::ai::AIState, &mut crate::combat::WeaponStats)>,
    mut intent_events: EventWriter<WeaponFireIntent>,
) {
    use crate::ai::AIState;

    for (entity, state, mut weapon) in actors.iter_mut() {
        // –°—Ç—Ä–µ–ª—è–µ–º —Ç–æ–ª—å–∫–æ –≤ Combat state
        let AIState::Combat { target } = state else {
            continue;
        };

        // –¢–æ–ª—å–∫–æ ranged weapons
        if !weapon.is_ranged() {
            continue;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º cooldown (strategic constraint)
        if !weapon.can_attack() {
            continue;
        }

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º intent (Godot –ø—Ä–æ–≤–µ—Ä–∏—Ç distance/LOS)
        intent_events.write(WeaponFireIntent {
            shooter: entity,
            target: Some(*target),
            damage: weapon.base_damage,
            speed: weapon.projectile_speed,
            max_range: weapon.range,
            hearing_range: weapon.hearing_range,
        });

        // –ù–∞—á–∏–Ω–∞–µ–º cooldown (ECS –≤–ª–∞–¥–µ–µ—Ç cooldown state)
        weapon.start_cooldown();

        crate::log(&format!(
            "Actor {:?} wants to fire at {:?} (intent generated)",
            entity, target
        ));
    }
}

/// System: –æ–±—Ä–∞–±–æ—Ç–∫–∞ ProjectileHit —Å–æ–±—ã—Ç–∏–π ‚Üí –Ω–∞–Ω–µ—Å–µ–Ω–∏–µ —É—Ä–æ–Ω–∞
///
/// Godot –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–±—ã—Ç–∏–µ –ø–æ—Å–ª–µ collision detection.
/// –ü—Ä–∏–º–µ–Ω—è–µ—Ç damage —Å —É—á—ë—Ç–æ–º shield (ranged –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è —â–∏—Ç–æ–º).
pub fn process_projectile_hits(
    mut hit_events: EventReader<ProjectileHit>,
    mut targets: Query<(&mut crate::Health, Option<&mut crate::components::EnergyShield>)>,
    mut damage_events: EventWriter<crate::combat::DamageDealt>,
) {
    for hit in hit_events.read() {
        crate::log(&format!(
            "üéØ ProjectileHit: shooter={:?} ‚Üí target={:?} dmg={} at {:?}",
            hit.shooter, hit.target, hit.damage, hit.impact_point
        ));

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ self-hit (–Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å!)
        if hit.shooter == hit.target {
            crate::log(&format!(
                "‚ö†Ô∏è SELF-HIT DETECTED! Entity {:?} hit itself!",
                hit.shooter
            ));
            continue; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º self-damage
        }

        // –ù–∞–Ω–æ—Å–∏–º —É—Ä–æ–Ω —Ü–µ–ª–∏ (—Å —É—á—ë—Ç–æ–º shield)
        let Ok((mut health, mut shield_opt)) = targets.get_mut(hit.target) else {
            continue;
        };

        let applied = crate::combat::apply_damage_with_shield(
            &mut health,
            shield_opt.as_deref_mut(),
            hit.damage,
            crate::combat::DamageSource::Ranged,
        );

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º DamageDealt event –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω—ã—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
        damage_events.write(crate::combat::DamageDealt {
            attacker: hit.shooter,
            target: hit.target,
            damage: hit.damage,
            source: crate::combat::DamageSource::Ranged,
            applied_damage: applied,
            impact_point: hit.impact_point,
            impact_normal: hit.impact_normal,
        });

        crate::log(&format!(
            "üí• Projectile damage applied: {:?} (HP: {})",
            applied, health.current
        ));
    }
}

/// System: –æ–±—Ä–∞–±–æ—Ç–∫–∞ ProjectileShieldHit —Å–æ–±—ã—Ç–∏–π ‚Üí —Ä–∞–∑—Ä—è–¥–∫–∞ —â–∏—Ç–∞
///
/// Godot –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–±—ã—Ç–∏–µ –∫–æ–≥–¥–∞ projectile –∫–æ–ª–ª–∏–¥–∏—Ä—É–µ—Ç —Å ShieldSphere.
/// –ü—Ä–∏–º–µ–Ω—è–µ—Ç damage —Ç–æ–ª—å–∫–æ –∫ —â–∏—Ç—É (—É—Ä–æ–Ω –≤ health –Ω–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç).
/// Self-shield bypass —É–∂–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω –≤ Godot layer.
pub fn process_projectile_shield_hits(
    mut hit_events: EventReader<ProjectileShieldHit>,
    mut targets: Query<(&mut crate::Health, Option<&mut crate::components::EnergyShield>)>,
    mut damage_events: EventWriter<crate::combat::DamageDealt>,
) {
    for hit in hit_events.read() {
        crate::log(&format!(
            "üõ°Ô∏è ProjectileShieldHit: shooter={:?} ‚Üí shield={:?} dmg={} at {:?}",
            hit.shooter, hit.target, hit.damage, hit.impact_point
        ));

        // Paranoid validation: shooter != target (–¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —É–∂–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ –≤ Godot)
        if hit.shooter == hit.target {
            crate::log(&format!(
                "‚ö†Ô∏è SELF-SHIELD HIT! This should never happen (Godot bug?). Entity {:?}",
                hit.shooter
            ));
            continue;
        }

        // –ù–∞–Ω–æ—Å–∏–º —É—Ä–æ–Ω —â–∏—Ç—É (–Ω–µ —Ç—Ä–æ–≥–∞–µ–º health)
        let Ok((mut health, mut shield_opt)) = targets.get_mut(hit.target) else {
            continue;
        };

        let applied = crate::combat::apply_damage_with_shield(
            &mut health,
            shield_opt.as_deref_mut(),
            hit.damage,
            crate::combat::DamageSource::Ranged, // Shield blocks ranged
        );

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º DamageDealt event –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω—ã—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
        damage_events.write(crate::combat::DamageDealt {
            attacker: hit.shooter,
            target: hit.target,
            damage: hit.damage,
            source: crate::combat::DamageSource::Ranged,
            applied_damage: applied,
            impact_point: hit.impact_point,
            impact_normal: hit.impact_normal,
        });

        crate::log(&format!(
            "üõ°Ô∏è Shield absorbed damage: {:?} (HP: {} ‚Äî untouched)",
            applied, health.current
        ));
    }
}

// ‚ùå cleanup_projectiles —É–¥–∞–ª–µ–Ω–∞ ‚Äî Godot –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–ø—Ä–∞–≤–ª—è–µ—Ç lifecycle

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_projectile_hit_event() {
        let shooter = Entity::PLACEHOLDER;
        let target = Entity::from_raw(1);

        let hit = ProjectileHit {
            shooter,
            target,
            damage: 20,
            impact_point: Vec3::ZERO,
            impact_normal: Vec3::Z,
        };

        assert_eq!(hit.shooter, shooter);
        assert_eq!(hit.damage, 20);
        assert_eq!(hit.impact_point, Vec3::ZERO);
    }
}
