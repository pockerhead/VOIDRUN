//! Combat events (ECS ↔ Godot communication).
//!
//! All combat-related events for melee, ranged, damage, and shields.

use bevy::prelude::*;
use super::components::melee::MeleeAttackType;

// ============================================================================
// Melee Events
// ============================================================================

/// AI wants to perform a melee attack (ECS strategic decision).
///
/// Generated by `ai_melee_attack_intent` system when:
/// - AI is in Combat state
/// - Weapon is melee type
/// - Target is within attack radius (strategic estimate)
/// - Cooldown is ready
///
/// Processed by `process_melee_attack_intents_main_thread` (Godot tactical validation).
///
/// **CHANGED:** No target field (area-based detection, hitbox determines targets).
#[derive(Event, Clone, Debug)]
pub struct MeleeAttackIntent {
    /// Entity initiating attack
    pub attacker: Entity,
    /// Attack type (Normal/Heavy/Quick)
    pub attack_type: MeleeAttackType,
}

/// Melee attack has been approved and started (Godot tactical validation passed).
///
/// Generated by `process_melee_attack_intents_main_thread` after:
/// - Distance check (Godot Transform)
/// - Line of sight check (optional)
///
/// Processed by `start_melee_attacks` system (ECS):
/// - Adds `MeleeAttackState` component (phase = Windup)
/// - Starts weapon cooldown
///
/// **CHANGED:** No target field (area-based detection, hitbox determines targets).
#[derive(Event, Clone, Debug)]
pub struct MeleeAttackStarted {
    /// Entity performing attack
    pub attacker: Entity,
    /// Attack type
    pub attack_type: MeleeAttackType,
    /// Windup phase duration (seconds)
    pub windup_duration: f32,
    /// Active phase duration (seconds)
    pub attack_duration: f32,
    /// Recovery phase duration (seconds)
    pub recovery_duration: f32,
}

/// Melee hitbox collision detected (Godot → ECS).
///
/// Generated by Godot when weapon hitbox (Area3D) collides with target.
/// Queued in `MELEE_HIT_QUEUE`, processed by `process_melee_hits` system.
///
/// Results in `DamageDealt` event if not blocked/parried.
#[derive(Event, Clone, Debug)]
pub struct MeleeHit {
    /// Entity that hit
    pub attacker: Entity,
    /// Entity that was hit
    pub target: Entity,
    /// Base damage (before modifiers)
    pub damage: u32,
    /// Was attack blocked? (damage reduction 70%)
    pub was_blocked: bool,
    /// Was attack parried? (damage negated 100%, attacker staggered)
    pub was_parried: bool,
    /// Точка попадания (target body center, для VFX)
    pub impact_point: Vec3,
    /// Нормаль поверхности (attacker→target direction, для VFX)
    pub impact_normal: Vec3,
}

/// Parry attempt initiated (player/AI wants to parry).
///
/// Generated by AI or player input system.
/// Processed by `start_parry` system to add ParryState component.
///
/// **Note:** `attacker` can be None for idle/defensive parry (player practicing).
#[derive(Event, Clone, Debug)]
pub struct ParryIntent {
    /// Entity attempting to parry
    pub defender: Entity,
    /// Entity being parried (attacker).
    /// - `Some(entity)`: Targeted parry (AI or player with visible enemy)
    /// - `None`: Idle parry (player training/preemptive defense)
    pub attacker: Option<Entity>,
    /// Expected windup duration of incoming attack (unused for idle parry)
    pub expected_windup_duration: f32,
}

/// Parry successfully blocked an attack.
///
/// Generated by `detect_parry_success` system when:
/// - Attacker in ActiveParryWindow phase
/// - Defender has active ParryState
///
/// Results in:
/// - Attacker gets StaggerState
/// - Attack cancelled (skips ActiveHitbox phase)
/// - Defender gets counter attack window (TODO)
#[derive(Event, Clone, Debug)]
pub struct ParrySuccess {
    /// Entity that attacked
    pub attacker: Entity,
    /// Entity that parried
    pub defender: Entity,
}

// ============================================================================
// Ranged Combat Events
// ============================================================================

/// Event: Актёр ХОЧЕТ выстрелить (ECS strategic intent)
/// ECS принимает strategic decision: "cooldown готов, target в Combat state"
/// Godot validation проверяет tactical constraints: distance, LOS
///
/// **Note:** `target` опционален для player FPS shooting (direction = camera forward)
#[derive(Event, Debug, Clone)]
pub struct WeaponFireIntent {
    /// Кто хочет стрелять
    pub shooter: Entity,

    /// В кого хочет стрелять (None = player FPS shooting без target)
    pub target: Option<Entity>,

    /// Урон (из Weapon component)
    pub damage: u32,

    /// Скорость пули (из Weapon component)
    pub speed: f32,

    /// Max range (из Weapon component)
    pub max_range: f32,

    /// Радиус слышимости выстрела (для AI reaction)
    pub hearing_range: f32,
}

/// Event: Актёр стреляет (ECS → Godot, после validation)
/// Godot tactical layer проверил distance/LOS и разрешил выстрел
/// Godot рассчитывает точное direction из weapon bone (+Z axis)
///
/// **Note:** `target` опционален (None = player FPS shooting, direction = weapon forward)
#[derive(Event, Debug, Clone)]
pub struct WeaponFired {
    /// Кто стреляет
    pub shooter: Entity,

    /// В кого стреляет (None = направление из weapon bone, Some = fallback shooter→target)
    pub target: Option<Entity>,

    /// Урон пули
    pub damage: u32,

    /// Скорость пули
    pub speed: f32,

    /// Позиция стрелявшего (Godot Transform, для AI sound reaction)
    pub shooter_position: Vec3,

    /// Радиус слышимости выстрела (для AI reaction)
    pub hearing_range: f32,
}

/// Event: Projectile попал в цель (Godot → ECS)
#[derive(Event, Debug, Clone)]
pub struct ProjectileHit {
    /// Кто выстрелил (для предотвращения self-hit)
    pub shooter: Entity,

    /// В кого попали
    pub target: Entity,

    /// Урон
    pub damage: u32,

    /// Точка попадания (для VFX)
    pub impact_point: Vec3,

    /// Нормаль поверхности (для VFX направления)
    pub impact_normal: Vec3,
}

/// Event: Projectile попал в щит (Godot → ECS)
///
/// Генерируется когда projectile коллидирует с ShieldSphere (Area3D).
/// Shield блокирует projectile если:
/// - shooter != target (свой щит не блокирует)
/// - shield.is_active() (energy > 0)
#[derive(Event, Debug, Clone)]
pub struct ProjectileShieldHit {
    /// Projectile entity (для despawn в Godot)
    pub projectile: Entity,

    /// Кто выстрелил
    pub shooter: Entity,

    /// Владелец щита (target)
    pub target: Entity,

    /// Урон
    pub damage: u32,

    /// Точка попадания в щит (для ripple VFX)
    pub impact_point: Vec3,

    /// Нормаль поверхности (для VFX направления)
    pub impact_normal: Vec3,
}

// ============================================================================
// Damage Events
// ============================================================================

/// Source of damage (для разных эффектов/звуков)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Reflect)]
pub enum DamageSource {
    /// Melee weapon hit
    Melee,
    /// Ranged projectile hit
    Ranged,
    /// Environmental (TODO: future)
    Environmental,
}

/// Результат применения урона (для визуальных эффектов)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Reflect)]
pub enum AppliedDamage {
    /// Щит поглотил весь урон
    ShieldAbsorbed,
    /// Щит пробит, остаток урона прошёл в health
    ShieldBrokenWithOverflow(u32),
    /// Урон прошёл напрямую (melee или щита нет)
    Direct,
}

/// Событие: урон нанесен
///
/// Генерируется после применения damage к Health (и щиту если есть).
/// Используется для UI, звуков, эффектов.
#[derive(Event, Debug, Clone)]
pub struct DamageDealt {
    pub attacker: Entity,
    pub target: Entity,
    pub damage: u32,
    pub source: DamageSource,
    /// Результат применения урона (shield absorption status)
    pub applied_damage: AppliedDamage,
    /// Точка попадания (для VFX spawn position)
    pub impact_point: Vec3,
    /// Нормаль поверхности (для VFX направления)
    pub impact_normal: Vec3,
}

/// Событие: entity умер (health <= 0)
#[derive(Event, Debug, Clone)]
pub struct EntityDied {
    pub entity: Entity,
    pub killer: Option<Entity>,
}

// ============================================================================
// Attack Type Enum (shared between melee events and components)
// ============================================================================

/// Type of attack (for telegraph detection).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Reflect)]
pub enum AttackType {
    /// Melee attack
    Melee,
    /// Ranged attack
    Ranged,
}
